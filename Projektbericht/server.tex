\subsection*{Spezifische Vorgaben}
Um die leichte Weiterentwicklung der Serverkomponente durch kommende Studentengruppen und Institutsmitarbeiter zu erleichtern, war als Programmiersprache Java zu verwenden. Desweiteren war, wie auch in den anderen Komponenten von ToureNPlaner, auf eine leichte Erweiterbarkeit um neue Algorithmen zu achten, was sich in einem relativ generischen Design widerspiegelt.\\
Um möglichst einfach neue Clients entwickeln zu können und vorhandene Technologien wie Load Balancer direkt nutzen zu können, wurde früh festgelegt, dass der Server per HTTP und JSON ansprechbar sein soll.\\
Eine weitere Vorgabe ergab sich durch das beim Institut verfügbare Kartenmaterial, so war Kartenmaterial mit vorberechneten Contraction Hierarchies vorhanden, so dass diese bei den Algorithmen genutzt werden konnten und in die Entwicklung der Graphrepräsentation einflossen. Dabei mussten auch Änderungen im Format der Graphdaten, auch in fortgeschrittenen Entwicklungsphasen, schnell bewältigt werden können.
\subsection*{Organisatorisches}
Mit 4 Personen war das Serverteam das größte Teilteam des Projekts, weshalb eine, wenn auch flache, Hierarchie innerhalb des Teams sinnvoll erschien. So wurde Niklas Schnelle als Teamleiter gewählt, dem eine gewisse Entscheidungshoheit in Architektur- und Entwicklungsfragen zufiel, um diese schnell und unbürokratisch treffen zu können.\\
Im Laufe des Projekts wurden dann alle Aufgabenpakete - zu gleichen Teilen - über die 4 Teammitglieder verteilt.
So übernahm Sascha Meusel große Teile der für die Benutzer und Requestverwaltung nötigen Bereiche wie zum Beispiel die Entwicklung der Datenbankanbindung.
Peter Vollmer konzentrierte sich auf die Entwicklung des Constrained Shortest Path Algorithmus und des Systemtests, während Christoph Haag die Qualitätssicherung übernahm und bei der Entwicklung der Graphrepräsentation große Teile übernahm. Der Teamleiter schließlich entwickelte die Grundstruktur des Servers und der Graphrepräsentation, die Integration mit den verwendeten Bibliotheken und Teilmodulen sowie den Shortest Path und Traveling Salesmen Algorithmus.\\
In seiner Struktur lehnten wir uns somit stark an das Chief Programmer Modell an. Der Teamleiter war direkt in die Entwicklung eingebunden, und ein Großteil der Entwicklung fand gemeinsam in einem Raum statt, so dass es keinen Bedarf für festgelegte Meetings gab.
\subsection*{Umsetzung}
\subsubsection*{Externe Bibliotheken}
Als Grundlage des Servers diente das Netzwerkframework Netty\footnote{\url{http://www.jboss.org/netty}} des JBoss Projekts. Hierbei handelt es sich um ein Java Framework für die Entwicklung Event basierter Serversysteme, welches leicht benutzbare Primitive für die Umsetzung eines HTTP Servers liefert, ohne dabei einen schwergewichtigen Java Application Server oder ähnlichem zu benutzen. Vielmehr wird das HTTP Protokoll direkt in die eigene Software integriert und zur direkten Schnittstelle zur Außenwelt.\\
Zur Behandlung der als JSON kodierten Eingabedaten wurde schließlich die Bibliothek Jackson\footnote{\url{http://wiki.fasterxml.com/JacksonHome}} verwendet, welche auch ein zu JSON kompatibles Binärformat namens \glqq Smile\grqq unterstützt.
\subsubsection*{Graphrepräsentation}
Da Performanz vor allem bei der Ausführung von Graphalgorithmen für die Entwicklung des Servers als entscheidende Eigenschaft angesehen wurde, lag besondere Aufmerksamkeit auf der Entwicklung einer leistungsfähigen, schlanken und dennoch leicht zu benutzenden Graphrepräsentation.\\
Aufgrund der Vorraussetzung, den Server in Java zu entwickeln, mussten hierzu einige Kniffe angewendet werden.
So ist es in Java sehr problematisch, eine große Anzahl an Objekten anzulegen und zu Verwalten, und es werden keine  \glqq struct\grqq Datentypen unterstützt, die ohne große Speicherverwaltung und Referenzen auskommen.
Daher musste die Struktur des Graphs in einer Menge von Arrays atomarer Datentypen wie zum Beispiel \glqq int\grqq abgelegt werden.\\
Um dennoch ein benutzbares Interface zu bieten; wurden diese Details, soweit ohne Performance einbußen möglich,  hinter durch den Compiler leicht inlinebarer Methoden versteckt.\\
So können Kanten und Knoten des Graphs über ganzzahlige Ids angesprochen werden, ohne die genaue Repräsentation zu kennen.
\subsubsection*{Datenbankanbindung}
Die Anbindung der für die Verwaltung von Nutzern und gespeicherten Requests benötige Datenbankanbindung wurde mit Hilfe von direktem JDBC programmiert und in einer speziellen Manager Klasse gekapselt.
\subsubsection*{Algorithmen}
Die Entwicklung der eigentlichen Algorithmen erfolgte in Form spezieller Klassen, die sowohl die benötigen Datenstruktuen (z.B. Priority Queue im Dijkstra) als auch die Implementierung des Algorithmus zusammenfassen.\\
Dabei wird für alle Graphalgorithmen in Abstimmung mit den Clients die gleiche Struktur der Eingabedaten verwendet, so dass diese vor Ausführung der Algorithmen bereits vorverarbeitet werden können und diesen direkt als Objekt zur Verfügung stehen. Desweiteren können alle Algorithmen die Daten der Contraction Hierarchie nutzen, aber auch andere Algorithmen. So nutzt zum Beispiel der Traveling Salesmen Algorithmus zur Berechnung einer kürzeste Wege Distanzmatrix, die Implementierung des Shortest Path Algorithmus.\\
