\documentclass[ngerman,titlepage,parskip=true]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage{array}
\usepackage{babel}
\usepackage{wrapfig}
\usepackage{longtable}
\usepackage[unicode=true,pdfusetitle,bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,breaklinks=false,pdfborder={0 0 0},backref=false,colorlinks=false]{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage{tabularx}

\lstset{ %
	language=java,                % the language of the code
	basicstyle=\footnotesize,       % the size of the fonts that are used for the code
	numbers=left,                   % where to put the line-numbers
	numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
	stepnumber=2,                   % the step between two line-numbers. If it's 1, each line 
	                                % will be numbered
	numbersep=5pt,                  % how far the line-numbers are from the code
	backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
	showspaces=false,               % show spaces adding particular underscores
	showstringspaces=false,         % underline spaces within strings
	showtabs=false,                 % show tabs within strings adding particular underscores
	frame=single,                   % adds a frame around the code
	tabsize=4,                      % sets default tabsize to 2 spaces
	captionpos=b,                   % sets the caption-position to bottom
	breaklines=true,                % sets automatic line breaking
	breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
	title=\lstname,                 % show the filename of files included with \lstinputlisting;
	                                % also try caption instead of title
	escapeinside={\%*}{*)},         % if you want to add a comment within your code
	morekeywords={*,...}            % if you want to add more keywords to the set
}

% adjust table padding
\setlength{\tabcolsep}{8pt} \renewcommand{\arraystretch}{1.5}
 
\title{Developer Manual}
\author{ToureNPlaner Team}

%\begin{lstlisting}
%put your code here
%\end{lstlisting}

\begin{document}

\maketitle

\tableofcontents

\pagebreak

\section{Introduction}

Writing algorithm classes for ToureNPlaner consists of three easy steps:
\begin{itemize}
  \item Write an algorithm
  \item Write a factory that creates instances of that algorithm
  \item Register the factory in the algorithmregistry
\end{itemize}


  \subsection{Overview: How Algorithms in ToureNPlaner work}
  After a request from a client to the server has been received by netty server.AlgorithmHandler will do the following things:
  \begin{itemize}
    \item from the URL suffix \textit{/alg\textbf{myalg}} checks, whether there is an algorithm factory in the algorithm registry that provides \textbf{myalg} via the getURLSuffix() method
    \item if in private mode, writes the request to the database
    \item gives the request object (name of the algorithm, a responder object in which the result can be written, the data from the request) to the queue
  \end{itemize}
  Each ComputeThread (nondeterministically) takes a request object out of the queue, gets the correct algorithm factory from the algorithm manager via the algorithm suffix in the request and getURLSuffix() in the factory, starts the MyAlgorithm.compute() method, initiates writing of the response object (original way, calculated result way, misc information) back to netty.\\
  In MyAlgorithm compute(Computerequest req) is called. After the calculation is done MyAlgorithm should put the resulting way in the Points object acquired with req.getResulWay() and additional information in a misc object with req.setMisc(Object o).

\section{Detailed Steps}

  \subsection{How to write an Algorithm}

    \subsubsection{The algorithm class}
		A new Algorithm will almost surely inherit from the abstract GraphAlgorithm class (which implements the Algorithm interface). Only in the unlikely case that the new algorithm does not run on the graph it can directly implement the Algorithm interface.\\
		Algorithm (and GraphAlgorithm) is are very simple to implement: It only requires to implement the compute(ComputeRequest req) method.
		The req object allows to get the following information
		\begin{itemize}
		  \item The points the client sent: req.getPoints()
		  \item The constraints the client sent: req.getConstraints()
		\end{itemize}
		Now the actual algorithm can be implemented using this information.\\
		After calculating the result it should be returned to the client. Since java has no good mechanism to return arbitrary ``structs'' we decided to write the result directly into the response object.\\
		This information should be written:
		\begin{itemize}
		  \item the resulting way, into the Points object acquired by req.getResultWay()
		  \item optionally an arbitrary misc object as long as jackson can map it to json (for example, a Map): req.setMisc(Object o)
		\end{itemize}


	 \subsubsection{The factory class}
  
  \subsection{Data Structure Sharing}

  \subsection{Finishing steps}
  The algorithm factory needs to be \textit{registered} in the AlgorithmRegistry. This is also the place to pass the graph to the algorithm.
  In the server.TourenPlaner class do:
  \begin{lstlisting}[language=java,caption=register your algorithm factory]
          reg.registerAlgorithm(new MyAlgorithmFactory(graph));
  \end{lstlisting}
  
  \section{Example}
	 \subsection{Proto classes}
	 \lstinputlisting[language=Java,caption=``Factory Class'']{ProtoAlgorithmFactory.java}
	 \lstinputlisting[language=Java,caption=``Algorithm Class'']{ProtoAlgorithm.java}

\end{document}